%% ΑΣΚΗΣΗ 1
%% Β ΜΕΡΟΣ
% Κωδικοποιηση Διακριτης Πηγης με τη μεθοδο DPCM
%
%% Εισοδος
% δινονται τα δεδομενα εισοδου
%
load source.mat;
x=t(15001:20000);
%
%% Υπολογισμος συντελεστη φιλτρου προβλεψης
%
% Αριθμος προηγουμενων τιμων στη μνημη
p=10;
% Bits κβαντισης
N=1;
%
% Μεγεθος εισοδου
lgth=length(x);
%
% Διανυσμα αυτοσυσχετισης
for i=1:p
    r1=0;
    for n=p+1:lgth
        r1=r1+x(n)*x(n-i);
    end
    r(i)=(1/(lgth-p))*r1;
end
%
% Πινακας αυτοσυσχετισης
for i=1:p
    for j=1:p
        R1=0;
        for n=p:lgth
            R1=R1+x(n-j+1)*x(n-i+1);
        end
        R(i,j)=(1/(lgth-p+1))*R1;
    end
end
% Συντελεστης φιλτρου προβλεψης
a=r*(R^(-1));
% Κβαντιση του a
a_quant = my_quantizer(a, 8, -2, 2)
%--------------QUANTIZER--------------------------------------
% Αρχικοποιηση της y1
%y=a;
%N=8; % Μονο για το a
%min_value=-2;
%max_value=2;
%
%for v=1:length(y)
%    y1(v)=0;
%end
% Αριθμος επιπεδων κβαντισης
%L=2^N;
% Βημα κβαντισης
%D=2*(max_value/L);
% Κεντρα της καθε περιοχης
%for i=1:L
%    centers(i)= max_value-(i-1)*D-D/2;
%end
% Υπολογισμος περιοχης που ανηκει καθε δειγμα εισοδου
%
%lng=length(y);
%for k=1:lng
%    b=max_value-D;
%    s=min_value+D;
%    if y(k)>=b
%       y1(k)=1;
%    elseif y(k)<s
%       y1(k)= L;
%   elseif y(k)<b && y(k)>=0
%        d=1;
%        for j=0:((2^N)/2)-1 % τοσες επαναληψεις χρειαζεται για να 
%                            % υπολογισει σωστα το κεντρο της περιοχης
%            if y(k)<b-j*D
%               d=d+1;
%                y1(k)=d;
%            end
 %       end
 %    elseif y(k)<0 && y(k)>=s
 %        d=L;
 %       for j=0:((2^N)/2)-1          
%            if y(k)>=s+j*D
%                d=d-1;
%                y1(k)=d;
%            end
%        end
%    end    

% Κβαντισμενο δειγμα
%y1(k)=centers(y1(k));
%end  % της for k=1:lng
%a_quant=y1
%
%---------------------------------------------------------------
%
%% Υπολογισμος φιλτρου προβλεψης
%
% Αρχικο δειγμα χωρις κβαντιση και ανακατασκευη
y_re(1:p)=x(1:p);
% Αποθηκευση του αρχικου δειγματος στην μνημη για χρηση στον
% υπολογισμο της προβλεψης
for f=1:lgth
    memor(f)=0;
end
memor(1:p)=x(1:p);
%
% Τα 8 πρωτα δειγματα θα κβαντιστουν αλλα δεν θα ανακατασκευαστουν
% απο αυτο και επειτα το προγραμμα ακολουθει τις οδηγιες τις ασκησης
min=p+1;
y_perr2=0;
for k=min:lgth
    % Αρχικο δειγμα
    y_pred1=0;
    for i=1:p
        ki=k-i;
        y_pred1=y_pred1 + a_quant(i)*memor(ki);
    end
% Προβλεψη σηματος
y_pred(k)=y_pred1;
% Σφαλμα προβλεψης
y_perr(k)=x(k)-y_pred(k);
%
% Κβαντισμενο σφαλμα προβλεψης
y_qerr(k)=my_quantizer(y_perr(k), N, -3.5, 3.5);
%--------------QUANTIZER--------------------------------------
% Αρχικοποιηση της y1
%y=0;
%y(k)=y_perr(k);
%N=3;
%min_value=-3.5;
%max_value=3.5;
%
%for v=1:length(y)
%    y1(v)=0;
%end
% Αριθμος επιπεδων κβαντισης
%L=2^N;
% Βημα κβαντισης
%D=2*(max_value/L);
% Κεντρα της καθε περιοχης
%for i=1:L
%    centers(i)= max_value-(i-1)*D-D/2;
%end
% Υπολογισμος περιοχης που ανηκει καθε δειγμα εισοδου
%
%lng=length(y);
%for k=1:lng
%    b=max_value-D;
%    s=min_value+D;
%    if y(k)>=b
%       y1(k)=1;
%    elseif y(k)<s
%       y1(k)= L;
%    elseif y(k)<b && y(k)>=0
%        d=1;
%        for j=0:((2^N)/2)-1 % τοσες επαναληψεις χρειαζεται για να 
%                            % υπολογισει σωστα το κεντρο της περιοχης
%            if y(k)<b-j*D
%                d=d+1;
%                y1(k)=d;
%            end
%        end
%     elseif y(k)<0 && y(k)>=s
%         d=L;
%        for j=0:((2^N)/2)-1          
%            if y(k)>=s+j*D
%                d=d-1;
%                y1(k)=d;
%            end
%        end
%    end
%end
%

% Κβαντισμενο δειγμα
%y1(k)=centers(y1(k));
%end  % της for k=1:lng
%y_qerr(k)=y1(k);
%
%---------------------------------------------------------------
%
%% Ανακατασκευασμενο σημα
% Επειδη τα 8 πρωτα δειγματα δεν ειναι ανακατασκευασμενα
% το 9ο θα παρει το αρχικο 8ο δειγμα
% μετα θα συνεχιστει κανονικα
y_re(k)=y_qerr(k)+ y_pred(k);
% Ενημερωση της μνημης με την τιμη του ανακατασκευασμενου σηματος
memor(k)=y_re(k);
% Υπολογισμος  μεσου τετραγωνικου σφαλματος 
y_perr2=y_perr2 + y_perr(k)^2;
end
E=y_perr2/length(x);
figure
plot(x)
hold on
plot(y_re)
hold off
disp(N)
disp(p)
%